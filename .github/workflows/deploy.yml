name: CI/CD with AWS ECR and SSM

on:
  push:
    branches: [main]

env:
  AWS_REGION: eu-west-2
  ECR_REGISTRY: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.eu-west-2.amazonaws.com
  ECR_REPOSITORY: amdg

jobs:
  build-test-push:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Verify AWS credentials
        run: |
          aws sts get-caller-identity
          aws configure list

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Install Docker Compose
        run: |
          sudo curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
          sudo chmod +x /usr/local/bin/docker-compose
          docker-compose --version

      - name: Create .env.test file with DB password
        run: |
          cat > .env << EOF
          DB_PASSWORD=${{ secrets.TEST_DB_PASSWORD }}
          SECRET_KEY=test-secret-key-for-ci-only-not-for-production
          DEBUG=True
          ALLOWED_HOSTS=localhost,127.0.0.1,web
          DB_ENGINE=django.db.backends.postgresql
          DB_NAME=awstestdb
          DB_USER=postgres
          DB_HOST=db
          DB_PORT=5432
          AWS_STORAGE_BUCKET_NAME=test-bucket
          AWS_S3_REGION_NAME=eu-west-2
          ECR_REGISTRY=local-test-registry
          IMAGE_TAG=test-build
          EOF

      - name: Clean up old volumes
        run: |
          docker-compose down -v || true
          docker volume rm awsdjangotest_postgres_data awsdjangotest_redis_data || true

      - name: Build Docker containers for testing
        run: |
          docker-compose build

      - name: Start services
        run: |
          echo "Starting services..."
          docker-compose up -d || true
          echo "Services started, checking status..."
          docker-compose ps
          echo ""
          echo "=== POSTGRES LOGS ==="
          docker-compose logs db
          echo ""
          echo "=== REDIS LOGS ==="
          docker-compose logs redis
          echo ""
          echo "Waiting for health checks..."
          for i in {1..30}; do
            if docker inspect postgres_db --format='{{.State.Health.Status}}' | grep -q "healthy"; then
              echo "Postgres is healthy!"
              break
            fi
            echo "Attempt $i/30: Postgres not ready yet, waiting..."
            sleep 5
          done
          echo ""
          echo "=== WEB CONTAINER LOGS ==="
          docker-compose logs web
          echo ""
          echo "=== FINAL STATUS ==="
          docker-compose ps
          echo ""
          # Check if postgres is healthy
          if ! docker inspect postgres_db --format='{{.State.Health.Status}}' | grep -q "healthy"; then
            echo "ERROR: postgres_db is not healthy"
            docker inspect postgres_db --format='{{json .State.Health}}'
            exit 1
          fi
          # Check if web container is running (not just restarting)
          WEB_STATUS=$(docker inspect django_app --format='{{.State.Status}}')
          if [ "$WEB_STATUS" != "running" ]; then
            echo "ERROR: django_app is not running (status: $WEB_STATUS)"
            echo "=== FULL WEB LOGS ==="
            docker-compose logs web
            exit 1
          fi

      - name: Run migrations
        run: |
          docker-compose exec -T \
            -e AWS_ACCESS_KEY_ID=$AWS_ACCESS_KEY_ID \
            -e AWS_SECRET_ACCESS_KEY=$AWS_SECRET_ACCESS_KEY \
            -e AWS_REGION=$AWS_REGION \
            web python manage.py migrate --noinput

      - name: Run Django tests
        run: |
          docker-compose exec -T \
            -e AWS_ACCESS_KEY_ID=$AWS_ACCESS_KEY_ID \
            -e AWS_SECRET_ACCESS_KEY=$AWS_SECRET_ACCESS_KEY \
            -e AWS_REGION=$AWS_REGION \
            web python manage.py test

      - name: Cleanup test containers
        if: always()
        run: |
          docker-compose down -v

      - name: Build and push Django app image to ECR
        env:
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
          docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:latest
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
          echo "Pushed images:"
          echo "  - $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"
          echo "  - $ECR_REGISTRY/$ECR_REPOSITORY:latest"

  deploy:
    needs: build-test-push
    runs-on: ubuntu-latest

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Verify EC2 Status
        run: |
          aws ec2 describe-instance-status \
            --instance-ids ${{ secrets.EC2_INSTANCE_ID }} \
            --query 'InstanceStatuses[0].InstanceState.Name'
          
          aws ssm describe-instance-information \
            --filters "Key=InstanceIds,Values=${{ secrets.EC2_INSTANCE_ID }}"

      - name: Deploy to EC2 via SSM
        id: deploy_ssm
        env:
          IMAGE_TAG: ${{ github.sha }}
          ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
          INSTANCE_ID: ${{ secrets.EC2_INSTANCE_ID }}
        run: |
          aws ssm send-command \
            --instance-ids "$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --comment "Deploy Django Docker App from ECR - Image: $IMAGE_TAG" \
            --timeout-seconds 3600 \
            --parameters commands="[
              \"set -e\",              
              \"export HOME=/home/ec2-user\",
              \"export IMAGE_TAG=$IMAGE_TAG\",
              \"export ECR_REGISTRY=$ACCOUNT_ID.dkr.ecr.eu-west-2.amazonaws.com\",
              \"cd /home/ec2-user/awsdjangotest\",
              \"echo Deploying image: \$ECR_REGISTRY/amdg:\$IMAGE_TAG\",
              \"echo Cleaning up old Docker images to free space...\",
              \"docker system prune -af --volumes || true\",
              \"echo Logging in to ECR...\",
              \"aws ecr get-login-password --region eu-west-2 | docker login --username AWS --password-stdin \$ECR_REGISTRY\",
              \"echo Pulling image with tag \$IMAGE_TAG from ECR...\",
              \"docker-compose pull\",
              \"echo Stopping all containers and removing old containers...\",
              \"docker-compose down --remove-orphans\",
              \"echo Starting db and redis with fresh containers...\",
              \"docker-compose up -d --force-recreate --no-build db redis\",
              \"sleep 20\",
              "echo Starting web and celery_worker with force-recreate - NEW IMAGES...",
              \"docker-compose up -d --force-recreate --no-build web celery_worker\",
              \"echo Waiting for web to be ready...\",
              \"sleep 45\",
              \"echo Running migrations BEFORE starting celery_beat...\",
              \"docker-compose exec -T web python manage.py migrate --noinput\",
              \"echo Setting up Celery Beat tasks...\",
              \"docker-compose exec -T web python manage.py setup_event_lifecycle_tasks\",
              \"echo Now starting celery_beat with force-recreate after migrations complete...\",
              \"docker-compose up -d --force-recreate --no-build celery_beat\",
              \"echo Starting nginx with force-recreate...\",
              \"docker-compose up -d --force-recreate --no-build nginx\",
              \"sleep 10\",
              \"echo Final status...\",
              \"docker-compose ps\",
              \"echo Verifying new image is running...\",
              \"docker ps\",
              "echo Expected image tag: \$IMAGE_TAG",
              "docker images | grep amdg | head -5 || echo No amdg images found",
              \"echo Deployment complete - Image tag: \$IMAGE_TAG\"
            ]" \
            --output json > result.json
          
          COMMAND_ID=$(jq -r '.Command.CommandId' result.json)
          echo "command_id=$COMMAND_ID" >> $GITHUB_OUTPUT
          echo "Command ID: $COMMAND_ID"

      - name: Wait for deployment command to complete
        run: |
          COMMAND_ID="${{ steps.deploy_ssm.outputs.command_id }}"
          echo "Waiting for command $COMMAND_ID to complete..."
          
          # Wait up to 30 minutes (180 attempts * 10 seconds)
          for i in {1..180}; do
            STATUS=$(aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id "${{ secrets.EC2_INSTANCE_ID }}" \
              --query "Status" \
              --output text 2>/dev/null || echo "Pending")
            
            echo "Attempt $i/180: Status = $STATUS"
            
            if [ "$STATUS" = "Success" ]; then
              echo "Deployment completed successfully!"
              aws ssm get-command-invocation \
                --command-id "$COMMAND_ID" \
                --instance-id "${{ secrets.EC2_INSTANCE_ID }}" \
                --query "StandardOutputContent" \
                --output text
              exit 0
            elif [ "$STATUS" = "Failed" ]; then
              echo "Deployment failed!"
              echo "=== STDOUT ==="
              aws ssm get-command-invocation \
                --command-id "$COMMAND_ID" \
                --instance-id "${{ secrets.EC2_INSTANCE_ID }}" \
                --query "StandardOutputContent" \
                --output text
              echo ""
              echo "=== STDERR ==="
              aws ssm get-command-invocation \
                --command-id "$COMMAND_ID" \
                --instance-id "${{ secrets.EC2_INSTANCE_ID }}" \
                --query "StandardErrorContent" \
                --output text
              exit 1
            elif [ "$STATUS" = "Cancelled" ] || [ "$STATUS" = "TimedOut" ]; then
              echo "Deployment $STATUS"
              exit 1
            fi
            
            sleep 10
          done
          
          echo "Timeout waiting for deployment"
          exit 1

