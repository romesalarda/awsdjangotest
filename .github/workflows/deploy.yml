name: CI/CD with AWS ECR and SSM

on:
  push:
    branches: [main]

env:
  AWS_REGION: eu-west-2
  ECR_REGISTRY: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.eu-west-2.amazonaws.com
  ECR_REPOSITORY: amdg

jobs:
  build-test-push:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Verify AWS credentials
        run: |
          aws sts get-caller-identity
          aws configure list

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Install Docker Compose
        run: |
          sudo curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
          sudo chmod +x /usr/local/bin/docker-compose
          docker-compose --version

      - name: Create .env.test file with DB password
        run: |
          cat > .env << EOF
          DB_PASSWORD=${{ secrets.TEST_DB_PASSWORD }}
          SECRET_KEY=test-secret-key-for-ci-only-not-for-production
          DEBUG=True
          ALLOWED_HOSTS=localhost,127.0.0.1,web
          DB_ENGINE=django.db.backends.postgresql
          DB_NAME=awstestdb
          DB_USER=postgres
          DB_HOST=db
          DB_PORT=5432
          AWS_STORAGE_BUCKET_NAME=test-bucket
          AWS_S3_REGION_NAME=eu-west-2
          IMAGE_TAG=ci-build-${{ github.sha }}
          EOF

      - name: Clean up old volumes
        run: |
          docker-compose -f docker-compose.yml -f docker-compose.ci.yml down -v || true
          docker volume rm awsdocker_postgres_data awsdocker_redis_data || true

      - name: Build Docker containers for testing
        run: |
          # Use CI-specific compose file that includes build contexts
          export IMAGE_TAG=ci-build-${{ github.sha }}
          docker-compose -f docker-compose.yml -f docker-compose.ci.yml build

      - name: Start services
        run: |
          export IMAGE_TAG=ci-build-${{ github.sha }}
          echo "Starting services with IMAGE_TAG=$IMAGE_TAG..."
          docker-compose -f docker-compose.yml -f docker-compose.ci.yml up -d
          echo "Services started, checking status..."
          docker-compose -f docker-compose.yml -f docker-compose.ci.yml ps
          echo ""
          echo "=== POSTGRES LOGS ==="
          docker-compose -f docker-compose.yml -f docker-compose.ci.yml logs db
          echo ""
          echo "=== REDIS LOGS ==="
          docker-compose -f docker-compose.yml -f docker-compose.ci.yml logs redis
          echo ""
          echo "Waiting for health checks..."
          for i in {1..30}; do
            if docker inspect postgres_db --format='{{.State.Health.Status}}' 2>/dev/null | grep -q "healthy"; then
              echo "Postgres is healthy!"
              break
            fi
            echo "Attempt $i/30: Postgres not ready yet, waiting..."
            sleep 5
          done
          echo ""
          echo "=== WEB CONTAINER LOGS ==="
          docker-compose -f docker-compose.yml -f docker-compose.ci.yml logs web
          echo ""
          echo "=== FINAL STATUS ==="
          docker-compose -f docker-compose.yml -f docker-compose.ci.yml ps
          echo ""
          # Check if postgres is healthy
          if ! docker inspect postgres_db --format='{{.State.Health.Status}}' 2>/dev/null | grep -q "healthy"; then
            echo "ERROR: postgres_db is not healthy"
            docker inspect postgres_db --format='{{json .State.Health}}' 2>/dev/null || echo "Container does not exist"
            exit 1
          fi
          # Check if web container is running (not just restarting)
          WEB_STATUS=$(docker inspect django_app_test --format='{{.State.Status}}' 2>/dev/null || echo "missing")
          if [ "$WEB_STATUS" != "running" ]; then
            echo "ERROR: django_app_test is not running (status: $WEB_STATUS)"
            echo "=== FULL WEB LOGS ==="
            docker-compose -f docker-compose.yml -f docker-compose.ci.yml logs web
            exit 1
          fi

      - name: Run migrations
        run: |
          export IMAGE_TAG=ci-build-${{ github.sha }}
          docker-compose -f docker-compose.yml -f docker-compose.ci.yml exec -T \
            -e AWS_ACCESS_KEY_ID=$AWS_ACCESS_KEY_ID \
            -e AWS_SECRET_ACCESS_KEY=$AWS_SECRET_ACCESS_KEY \
            -e AWS_REGION=$AWS_REGION \
            web python manage.py migrate --noinput

      - name: Run Django tests
        run: |
          export IMAGE_TAG=ci-build-${{ github.sha }}
          docker-compose -f docker-compose.yml -f docker-compose.ci.yml exec -T \
            -e AWS_ACCESS_KEY_ID=$AWS_ACCESS_KEY_ID \
            -e AWS_SECRET_ACCESS_KEY=$AWS_SECRET_ACCESS_KEY \
            -e AWS_REGION=$AWS_REGION \
            web python manage.py test

      - name: Cleanup test containers
        if: always()
        run: |
          export IMAGE_TAG=ci-build-${{ github.sha }}
          docker-compose -f docker-compose.yml -f docker-compose.ci.yml down -v

      - name: Build and push Django app image to ECR
        env:
          IMAGE_TAG: ${{ github.sha }}
        run: |
          # Build the production image directly (not via docker-compose)
          # This ensures the image is tagged correctly for ECR
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
          docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:latest
          
          # Push both tags to ECR
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
          
          echo "âœ… Successfully pushed images to ECR:"
          echo "  - $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"
          echo "  - $ECR_REGISTRY/$ECR_REPOSITORY:latest"

  deploy:
    needs: build-test-push
    runs-on: ubuntu-latest

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Verify EC2 Status
        run: |
          aws ec2 describe-instance-status \
            --instance-ids ${{ secrets.EC2_INSTANCE_ID }} \
            --query 'InstanceStatuses[0].InstanceState.Name'
          
          aws ssm describe-instance-information \
            --filters "Key=InstanceIds,Values=${{ secrets.EC2_INSTANCE_ID }}"

      - name: Fetch secrets from SSM
        id: fetch_secrets
        run: |
          echo "SECRET_KEY=$(aws ssm get-parameter --name /prod/amdg/v1/SECRET_KEY --with-decryption --query Parameter.Value --output text)" >> $GITHUB_OUTPUT
          echo "DB_PASSWORD=$(aws ssm get-parameter --name /prod/amdg/v1/DB_PASSWORD --with-decryption --query Parameter.Value --output text)" >> $GITHUB_OUTPUT
          echo "AWS_STORAGE_BUCKET_NAME=$(aws ssm get-parameter --name /prod/amdg/v1/AWS_STORAGE_BUCKET_NAME --query Parameter.Value --output text)" >> $GITHUB_OUTPUT
          echo "ALLOWED_HOSTS=$(aws ssm get-parameter --name /prod/amdg/v1/ALLOWED_HOSTS --query Parameter.Value --output text)" >> $GITHUB_OUTPUT

      - name: Deploy to EC2 via SSM
        id: deploy_ssm
        env:
          IMAGE_TAG: ${{ github.sha }}
          ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
          INSTANCE_ID: ${{ secrets.EC2_INSTANCE_ID }}
          SECRET_KEY: ${{ steps.fetch_secrets.outputs.SECRET_KEY }}
          DB_PASSWORD: ${{ steps.fetch_secrets.outputs.DB_PASSWORD }}
          AWS_STORAGE_BUCKET_NAME: ${{ steps.fetch_secrets.outputs.AWS_STORAGE_BUCKET_NAME }}
          ALLOWED_HOSTS: ${{ steps.fetch_secrets.outputs.ALLOWED_HOSTS }}
        run: |
          aws ssm send-command \
            --instance-ids "$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --comment "Deploy Django Docker App from ECR - Image: $IMAGE_TAG" \
            --timeout-seconds 3600 \
            --parameters commands="[
              \"#!/bin/bash\",
              \"set -e\",              
              \"export HOME=/home/ec2-user\",
              \"export IMAGE_TAG='$IMAGE_TAG'\",
              \"export ECR_REGISTRY='$ACCOUNT_ID.dkr.ecr.eu-west-2.amazonaws.com'\",
              \"export SECRET_KEY='$SECRET_KEY'\",
              \"export DB_PASSWORD='$DB_PASSWORD'\",
              \"export AWS_STORAGE_BUCKET_NAME='$AWS_STORAGE_BUCKET_NAME'\",
              \"export ALLOWED_HOSTS='$ALLOWED_HOSTS'\",
              \"export DEBUG='False'\",
              \"export DB_ENGINE='django.db.backends.postgresql'\",
              \"export DB_NAME='awstestdb'\",
              \"export DB_USER='postgres'\",
              \"export DB_HOST='db'\",
              \"export DB_PORT='5432'\",
              \"export AWS_S3_REGION_NAME='eu-west-2'\",
              \"export DJANGO_SETTINGS_MODULE='core.settings'\",
              \"cd /home/ec2-user/awsdjangotest\",
              \"echo '==================================================='\",
              \"echo 'Deploying image:' \\$ECR_REGISTRY'/amdg:'\\$IMAGE_TAG\",
              \"echo '==================================================='\",
              \"echo ''\",
              \"echo '[1/9] Cleaning up old Docker resources...'\",
              \"docker system prune -af --volumes || true\",
              \"echo ''\",
              \"echo '[2/9] Logging in to Amazon ECR...'\",
              \"aws ecr get-login-password --region eu-west-2 | docker login --username AWS --password-stdin \\$ECR_REGISTRY\",
              \"echo ''\",
              \"echo '[3/9] Pulling image from ECR (production compose)...'\",
              \"docker-compose -f docker-compose.yml pull web celery_worker celery_beat\",
              \"echo ''\",
              \"echo '[4/9] Verifying pulled images...'\",
              \"docker images | grep amdg | head -5 || echo 'Warning: No amdg images found after pull'\",
              \"echo ''\",
              \"echo '[5/9] Stopping all containers and removing orphans...'\",
              \"docker-compose -f docker-compose.yml down --remove-orphans\",
              \"echo ''\",
              \"echo '[6/9] Starting database and redis services...'\",
              \"docker-compose -f docker-compose.yml up -d --no-build db redis\",
              \"sleep 20\",
              \"echo ''\",
              \"echo '[7/9] Starting web and celery_worker with NEW ECR IMAGE...'\",
              \"docker-compose -f docker-compose.yml up -d --no-build web celery_worker\",
              \"echo 'Waiting for web service to be healthy...'\",
              \"sleep 45\",
              \"echo ''\",
              \"echo '[8/9] Running database migrations...'\",
              \"docker-compose -f docker-compose.yml exec -T web python manage.py migrate --noinput\",
              \"echo ''\",
              \"echo 'Setting up Celery Beat scheduled tasks...'\",
              \"docker-compose -f docker-compose.yml exec -T web python manage.py setup_event_lifecycle_tasks\",
              \"echo ''\",
              \"echo 'Starting celery_beat service (after migrations)...'\",
              \"docker-compose -f docker-compose.yml up -d --no-build celery_beat\",
              \"echo ''\",
              \"echo '[9/9] Starting nginx reverse proxy...'\",
              \"docker-compose -f docker-compose.yml up -d --no-build nginx\",
              \"sleep 10\",
              \"echo ''\",
              \"echo '==================================================='\",
              \"echo 'Deployment Complete - Final Status'\",
              \"echo '==================================================='\",
              \"docker-compose -f docker-compose.yml ps\",
              \"echo ''\",
              \"echo 'Running containers:'\",
              \"docker ps --format 'table {{.Names}}\\\\t{{.Image}}\\\\t{{.Status}}'\",
              \"echo ''\",
              \"echo 'Successfully deployed image tag:' \\$IMAGE_TAG\"
            ]" \
            --output json > result.json
          
          COMMAND_ID=$(jq -r '.Command.CommandId' result.json)
          echo "command_id=$COMMAND_ID" >> $GITHUB_OUTPUT
          echo "Command ID: $COMMAND_ID"

      - name: Wait for deployment command to complete
        run: |
          COMMAND_ID="${{ steps.deploy_ssm.outputs.command_id }}"
          echo "Waiting for command $COMMAND_ID to complete..."
          
          # Wait up to 30 minutes (180 attempts * 10 seconds)
          for i in {1..180}; do
            STATUS=$(aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id "${{ secrets.EC2_INSTANCE_ID }}" \
              --query "Status" \
              --output text 2>/dev/null || echo "Pending")
            
            echo "Attempt $i/180: Status = $STATUS"
            
            if [ "$STATUS" = "Success" ]; then
              echo "Deployment completed successfully!"
              aws ssm get-command-invocation \
                --command-id "$COMMAND_ID" \
                --instance-id "${{ secrets.EC2_INSTANCE_ID }}" \
                --query "StandardOutputContent" \
                --output text
              exit 0
            elif [ "$STATUS" = "Failed" ]; then
              echo "Deployment failed!"
              echo "=== STDOUT ==="
              aws ssm get-command-invocation \
                --command-id "$COMMAND_ID" \
                --instance-id "${{ secrets.EC2_INSTANCE_ID }}" \
                --query "StandardOutputContent" \
                --output text
              echo ""
              echo "=== STDERR ==="
              aws ssm get-command-invocation \
                --command-id "$COMMAND_ID" \
                --instance-id "${{ secrets.EC2_INSTANCE_ID }}" \
                --query "StandardErrorContent" \
                --output text
              exit 1
            elif [ "$STATUS" = "Cancelled" ] || [ "$STATUS" = "TimedOut" ]; then
              echo "Deployment $STATUS"
              exit 1
            fi
            
            sleep 10
          done
          
          echo "Timeout waiting for deployment"
          exit 1

