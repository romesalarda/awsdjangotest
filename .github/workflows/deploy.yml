name: CI/CD with AWS SSM

on:
  push:
    branches: [main]

env:
  AWS_REGION: eu-west-2

jobs:
  build-and-test:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Verify AWS credentials
        run: |
          aws sts get-caller-identity
          aws configure list

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Install Docker Compose
        run: |
          sudo curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
          sudo chmod +x /usr/local/bin/docker-compose
          docker-compose --version

      - name: Create .env.test file with DB password
        run: |
          cat > .env << EOF
          DB_PASSWORD=${{ secrets.TEST_DB_PASSWORD }}
          SECRET_KEY=test-secret-key-for-ci-only-not-for-production
          DEBUG=True
          ALLOWED_HOSTS=localhost,127.0.0.1,web
          DB_ENGINE=django.db.backends.postgresql
          DB_NAME=awstestdb
          DB_USER=postgres
          DB_HOST=db
          DB_PORT=5432
          AWS_STORAGE_BUCKET_NAME=test-bucket
          AWS_S3_REGION_NAME=eu-west-2
          EOF

      - name: Clean up old volumes
        run: |
          docker-compose down -v || true
          docker volume rm awsdjangotest_postgres_data awsdjangotest_redis_data || true

      - name: Build Docker containers
        run: |
          docker-compose build

      - name: Start services
        run: |
          echo "Starting services..."
          docker-compose up -d || true
          echo "Services started, checking status..."
          docker-compose ps
          echo ""
          echo "=== POSTGRES LOGS ==="
          docker-compose logs db
          echo ""
          echo "=== REDIS LOGS ==="
          docker-compose logs redis
          echo ""
          echo "Waiting for health checks..."
          for i in {1..30}; do
            if docker inspect postgres_db --format='{{.State.Health.Status}}' | grep -q "healthy"; then
              echo "Postgres is healthy!"
              break
            fi
            echo "Attempt $i/30: Postgres not ready yet, waiting..."
            sleep 5
          done
          echo ""
          echo "=== WEB CONTAINER LOGS ==="
          docker-compose logs web
          echo ""
          echo "=== FINAL STATUS ==="
          docker-compose ps
          echo ""
          # Check if postgres is healthy
          if ! docker inspect postgres_db --format='{{.State.Health.Status}}' | grep -q "healthy"; then
            echo "ERROR: postgres_db is not healthy"
            docker inspect postgres_db --format='{{json .State.Health}}'
            exit 1
          fi
          # Check if web container is running (not just restarting)
          WEB_STATUS=$(docker inspect django_app --format='{{.State.Status}}')
          if [ "$WEB_STATUS" != "running" ]; then
            echo "ERROR: django_app is not running (status: $WEB_STATUS)"
            echo "=== FULL WEB LOGS ==="
            docker-compose logs web
            exit 1
          fi

      - name: Run migrations
        run: |
          docker-compose exec -T \
            -e AWS_ACCESS_KEY_ID=$AWS_ACCESS_KEY_ID \
            -e AWS_SECRET_ACCESS_KEY=$AWS_SECRET_ACCESS_KEY \
            -e AWS_REGION=$AWS_REGION \
            web python manage.py migrate --noinput

      - name: Run Django tests
        run: |
          docker-compose exec -T \
            -e AWS_ACCESS_KEY_ID=$AWS_ACCESS_KEY_ID \
            -e AWS_SECRET_ACCESS_KEY=$AWS_SECRET_ACCESS_KEY \
            -e AWS_REGION=$AWS_REGION \
            web python manage.py test

      - name: Cleanup test containers
        if: always()
        run: |
          docker-compose down -v

  deploy:
    needs: build-and-test
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Verify EC2 Status
        run: |
          aws ec2 describe-instance-status \
            --instance-ids ${{ secrets.EC2_INSTANCE_ID }} \
            --query 'InstanceStatuses[0].InstanceState.Name'
          
          aws ssm describe-instance-information \
            --filters "Key=InstanceIds,Values=${{ secrets.EC2_INSTANCE_ID }}"

      - name: Deploy to EC2 via SSM
        id: deploy_ssm
        run: |
          aws ssm send-command \
            --instance-ids "${{ secrets.EC2_INSTANCE_ID }}" \
            --document-name "AWS-RunShellScript" \
            --comment "Deploy Django Docker App" \
            --parameters '{"commands":["cd /home/ec2-user/awsdjangotest","git fetch --all","git checkout main","git reset --hard origin/main","docker-compose down","docker-compose build --no-cache","docker-compose up -d","sleep 60","docker-compose ps","docker-compose exec -T web python manage.py migrate --noinput","docker-compose exec -T web python manage.py setup_event_lifecycle_tasks","docker-compose ps"]}' \
            --output json > result.json

          COMMAND_ID=$(jq -r '.Command.CommandId' result.json)
          echo "command_id=$COMMAND_ID" >> $GITHUB_OUTPUT

      - name: Wait for deployment command to complete
        run: |
          aws ssm wait command-executed \
            --command-id "${{ steps.deploy_ssm.outputs.command_id }}" \
            --instance-id "${{ secrets.EC2_INSTANCE_ID }}"

