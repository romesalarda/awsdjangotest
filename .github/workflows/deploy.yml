name: CI/CD with AWS SSM

on:
  push:
    branches: [main]

env:
  AWS_REGION: eu-west-2

jobs:
  build-and-test:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Verify AWS credentials
        run: |
          aws sts get-caller-identity
          aws configure list

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Install Docker Compose
        run: |
          sudo curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
          sudo chmod +x /usr/local/bin/docker-compose
          docker-compose --version

      - name: Create .env.test file with DB password
        run: |
          cat > .env << EOF
          DB_PASSWORD=${{ secrets.TEST_DB_PASSWORD }}
          SECRET_KEY=test-secret-key-for-ci-only-not-for-production
          DEBUG=True
          ALLOWED_HOSTS=localhost,127.0.0.1,web
          DB_ENGINE=django.db.backends.postgresql
          DB_NAME=awstestdb
          DB_USER=postgres
          DB_HOST=db
          DB_PORT=5432
          AWS_STORAGE_BUCKET_NAME=test-bucket
          AWS_S3_REGION_NAME=eu-west-2
          EOF

      - name: Clean up old volumes
        run: |
          docker-compose down -v || true
          docker volume rm awsdjangotest_postgres_data awsdjangotest_redis_data || true

      - name: Build Docker containers
        run: |
          docker-compose build

      - name: Start services
        run: |
          echo "Starting services..."
          docker-compose up -d || true
          echo "Services started, checking status..."
          docker-compose ps
          echo ""
          echo "=== POSTGRES LOGS ==="
          docker-compose logs db
          echo ""
          echo "=== REDIS LOGS ==="
          docker-compose logs redis
          echo ""
          echo "Waiting for health checks..."
          for i in {1..30}; do
            if docker inspect postgres_db --format='{{.State.Health.Status}}' | grep -q "healthy"; then
              echo "Postgres is healthy!"
              break
            fi
            echo "Attempt $i/30: Postgres not ready yet, waiting..."
            sleep 5
          done
          echo ""
          echo "=== WEB CONTAINER LOGS ==="
          docker-compose logs web
          echo ""
          echo "=== FINAL STATUS ==="
          docker-compose ps
          echo ""
          # Check if postgres is healthy
          if ! docker inspect postgres_db --format='{{.State.Health.Status}}' | grep -q "healthy"; then
            echo "ERROR: postgres_db is not healthy"
            docker inspect postgres_db --format='{{json .State.Health}}'
            exit 1
          fi
          # Check if web container is running (not just restarting)
          WEB_STATUS=$(docker inspect django_app --format='{{.State.Status}}')
          if [ "$WEB_STATUS" != "running" ]; then
            echo "ERROR: django_app is not running (status: $WEB_STATUS)"
            echo "=== FULL WEB LOGS ==="
            docker-compose logs web
            exit 1
          fi

      - name: Run migrations
        run: |
          docker-compose exec -T \
            -e AWS_ACCESS_KEY_ID=$AWS_ACCESS_KEY_ID \
            -e AWS_SECRET_ACCESS_KEY=$AWS_SECRET_ACCESS_KEY \
            -e AWS_REGION=$AWS_REGION \
            web python manage.py migrate --noinput

      - name: Run Django tests
        run: |
          docker-compose exec -T \
            -e AWS_ACCESS_KEY_ID=$AWS_ACCESS_KEY_ID \
            -e AWS_SECRET_ACCESS_KEY=$AWS_SECRET_ACCESS_KEY \
            -e AWS_REGION=$AWS_REGION \
            web python manage.py test

      - name: Cleanup test containers
        if: always()
        run: |
          docker-compose down -v

  deploy:
    needs: build-and-test
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Verify EC2 Status
        run: |
          aws ec2 describe-instance-status \
            --instance-ids ${{ secrets.EC2_INSTANCE_ID }} \
            --query 'InstanceStatuses[0].InstanceState.Name'
          
          aws ssm describe-instance-information \
            --filters "Key=InstanceIds,Values=${{ secrets.EC2_INSTANCE_ID }}"

      - name: Deploy to EC2 via SSM
        id: deploy_ssm
        run: |
          aws ssm send-command \
            --instance-ids "${{ secrets.EC2_INSTANCE_ID }}" \
            --document-name "AWS-RunShellScript" \
            --comment "Deploy Django Docker App" \
            --timeout-seconds 3600 \
            --parameters '{"commands":["#!/bin/bash","set -e","export HOME=/home/ec2-user","cd /home/ec2-user/awsdjangotest","git config --global --add safe.directory /home/ec2-user/awsdjangotest","echo Updating git remote to use HTTPS...","git remote set-url origin https://github.com/${{ github.repository }}.git","echo Fetching latest code...","git fetch --all","git checkout main","git reset --hard origin/main","echo Building containers...","docker-compose build","echo Stopping old containers...","docker-compose down","echo Starting new containers...","docker-compose up -d","echo Waiting for services to be healthy...","sleep 60","echo Checking container status...","docker-compose ps","echo Running migrations...","docker-compose exec -T web python manage.py migrate --noinput || echo Migration failed but continuing...","echo Setting up Celery Beat tasks...","docker-compose exec -T web python manage.py setup_event_lifecycle_tasks || echo Celery setup failed but continuing...","echo Final status...","docker-compose ps","echo Deployment complete!"]}' \
            --output json > result.json

          COMMAND_ID=$(jq -r '.Command.CommandId' result.json)
          echo "command_id=$COMMAND_ID" >> $GITHUB_OUTPUT
          echo "Command ID: $COMMAND_ID"

      - name: Wait for deployment command to complete
        run: |
          COMMAND_ID="${{ steps.deploy_ssm.outputs.command_id }}"
          echo "Waiting for command $COMMAND_ID to complete..."
          
          # Wait up to 30 minutes (180 attempts * 10 seconds)
          for i in {1..180}; do
            STATUS=$(aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id "${{ secrets.EC2_INSTANCE_ID }}" \
              --query "Status" \
              --output text 2>/dev/null || echo "Pending")
            
            echo "Attempt $i/180: Status = $STATUS"
            
            if [ "$STATUS" = "Success" ]; then
              echo "Deployment completed successfully!"
              aws ssm get-command-invocation \
                --command-id "$COMMAND_ID" \
                --instance-id "${{ secrets.EC2_INSTANCE_ID }}" \
                --query "StandardOutputContent" \
                --output text
              exit 0
            elif [ "$STATUS" = "Failed" ]; then
              echo "Deployment failed!"
              echo "=== STDOUT ==="
              aws ssm get-command-invocation \
                --command-id "$COMMAND_ID" \
                --instance-id "${{ secrets.EC2_INSTANCE_ID }}" \
                --query "StandardOutputContent" \
                --output text
              echo ""
              echo "=== STDERR ==="
              aws ssm get-command-invocation \
                --command-id "$COMMAND_ID" \
                --instance-id "${{ secrets.EC2_INSTANCE_ID }}" \
                --query "StandardErrorContent" \
                --output text
              exit 1
            elif [ "$STATUS" = "Cancelled" ] || [ "$STATUS" = "TimedOut" ]; then
              echo "Deployment $STATUS"
              exit 1
            fi
            
            sleep 10
          done
          
          echo "Timeout waiting for deployment"
          exit 1

